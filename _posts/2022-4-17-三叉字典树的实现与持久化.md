---
layout: post
author: shopkeeper
categories: algorithm neo4j
---

## 算法选择

假设：平均每一个需要建树的中文语句为 5 字符。实际上本系统中 POI 的名称的平均字符数会大于 5，这里取一个较小值以讨论算法的选取。

### 数据结构

- （×）经典字典树

- （√）三叉字典树

三叉字典树的数据结构较为简洁，空间上较优。在经典字典树中，以英文字母为例，每个节点最多可能有 26 个出度，及一个字母占有一个出度。三叉字典树最多只有三种关系，及`left`、`right`、`next`。`left`和`right`表示当前节点的左右兄弟，`next`表示下一个匹配字符。由经典字典树到三叉字典树的过程类似于树转换到二叉树的过程。

然而三叉字典树在时间上有所折损。经典字典树中直接通过对应的关系就能找到下一个字符的节点，但是三叉字典树多了一个在左右兄弟中匹配对应节点的过程。

### 字典中的字符

中文的字符（常用字约 5 万个）数量远远大于英文字符，在建树时需要考虑每个节点的字符取用。

- （×）汉字

  字典树的宽度太大。体现在三叉字典树中就是左右兄弟节点的深度过深。

- （×）汉语拼音全拼

  字典树的深度太大。一个汉字最少需要 1 个字母、最多需要 5 个字母来表示，取平均值 4 个字母，那么对一个 5 个字的关键字建树，需要大约 20 层。

- （?）汉语拼音的声母、韵母

  - 可能会导致歧义。例如`床`的拼音`chuang`，按照声母韵母分割为`ch`和`uang`，但是也可以被分割为`ch`、`u`、`ang`。
  - 为了避免这种歧义，需要对所有的声母和韵母都进行重新编码。如果进行重新编码处理之后，每一个汉字会被分为声母韵母两个节点（极少部分汉字只有韵母），同时声母和韵母的总数为 23 + 24 = 47 个。这种方式的节点深度和宽度均处于前两种方式之间，并且处于可接受范围之内。

- （√）汉语拼音的首字母

  匹配的结果可能存在大量无关数据。其实使用汉语拼音的处理方式都会面对一个问题：匹配的结果会获得大量的同音语句。只不过如果只是用汉语拼音的首字母，这个问题会越发严重——不止会返回同音的语句。例如对于首字母`c x`，可能会返回`程序`，也可能返回`查询`。这种方式在对返回结果的筛选需要较大量的时间，但是节点的深度和宽度都较小，查询字典树的速度会很快。

我分析了上述四种处理方式，首先排除前两种。我在使用声母和韵母之间徘徊不定，最后决定使用汉语拼音的首字母进行实现。

### 建树的字段的范围

- （×）全体 POI 节点（48 万条）

- （√）文旅节点（约 3000 条）

假设平均一个语句是 5 个汉字，一个汉字的取值范围为 26 个英文字母，当数据量足够多时，产生的节点数量为 26^5 > 1 千万。因此对于当前系统中的全体 48 万个 POI 节点均进行建树空间复杂度会爆炸。因此只针对 3000+个文旅数据进行建树。

从结果来看，对 3000 多条语句建立的树的节点就已经包含了 11000 个节点。证明了我选择的算法的合理之处。

## 算法实现

### 数据结构说明

定义字典树的每一个节点类型如下

```typescript
interface ITrieNode {
  left?: ITrieNode;
  right?: ITrieNode;
  next?: ITrieNode;
  char: string;
  titles?: string[];
  id?: number;
}
```

`left`、`right`、`next`的含义如上所示。`char` 为当前节点记录的字母，`titles` 记录从根节点匹配至当前节点的汉语拼音首字母序列的字符串，`id` 是当前节点的 id（可用于持久化存储）

### 建树

设`now`为当前子树的根节点，初始值为字典树的根节点（不携带数据）。对于中文语句的汉语拼音首字母序列`py[]`中的每一个字母`py`：

1. 如果 `now.next` 为空，为`now.next`创建新节点并赋值为`py`，令`now = now.next`，当前字母处理完成，进入第 5 步。否则进入第 2 步。

2. 此时`now.next`不为空，令`now = now.next`，当前步骤目的是找到`py`所处的位置。

3. 如果`now.char == py`，进入第步，否则进入第 4 步。

4. 判断`now.char`和`py`的大小关系。如果`now.char > py`，若 `now.left` 不为空，则 `now = now.left`，进入第 3 步；否则为`now.left`创建新节点并赋值为`py`，令`now = now.left`，当前字母处理完成，进入第 5 步。若`now.char < py`时同理。

5. 当前字母处理完成，若序列中仍有字符，则迭代`py`，进入第 1 步。否则进入第 6 步。

6. 此时`now.titles`为该字母序列的终点，将该语句写入到`now.titles`中。

### 查询

查询过程与建树过程类似，只不过当节点为空时，直接返回未找到即可。

## 持久化到 Neo4j 数据库

无论是建树（向树中插入新节点）还是查询的过程，首先都需要先将字典树获取到内存中。理由是 Neo4j 的 Cypher 语言不方便进行复杂逻辑查询。

重建树的过程是，分别从 Neo4j 中获取所有节点和节点之间的关系。例如：

```
vertexes: [a, b, c, d]
edges: [[a, b, next], [b, c, left], [b, d, right]]
```

对于每一个节点，由其在 Neo4j 中的 id 作为唯一标识，因此还需要使用 Map 来映射 id 和下标的对应关系：

```typescript
map.set(id(node), index(node));
```

对于一条边 [x, y, relationshipType]，x 和 y 均为节点的 id，那么建立重建这一条边的方式就是：

```typescript
vertexes[map.get(x)].relationshipType = vertexes[map.get(y)];
```

在建树和查询的过程中，所有遍历树的节点的操作都通过内存中重建的树进行。

### 建树

建树过程与算法实现中的过程相似，只不过是将新节点写入到 Neo4j 数据库中。

### 查询

查询过程与算法实现中的过程相似，现在针对返回结果的整合进行说明：

当匹配完最后一个字符时，需要收集当前节点及其后续节点上所有的 titles 字段并进行过滤。现有两种处理方式：

1. 在内存中的字典树中获取所有符合条件的节点的 Id，使用这些 Id 进行查询。关键语句为`WHERE id(n) in idList`。

2. 使用当前节点的 Id，前往数据库中查询所有后续节点，并返回 titles。关键语句为`MATCH (n)-[*0..]->(c)`。

在方式一中，待查询的节点被强行分割成了没有关系的独立的节点，仅使用 Id 的集合查询显然没有通过在 Neo4j 中利用树的连通性查询快捷。所以优先使用方式二。
